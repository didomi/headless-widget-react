{"version":3,"file":"static/js/5039.75f78e1f.chunk.js","mappings":"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","sources":["../node_modules/@didomi/ui-atoms/dist/esm/focus-trap.esm-1346aedd.js","../node_modules/@didomi/ui-atoms/dist/esm/utils-0574000f.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"],"sourcesContent":["/*!\n* tabbable 5.2.1\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\nvar isContentEditable = function isContentEditable(node) {\n  return node.contentEditable === 'true';\n};\n\nvar getTabindex = function getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  } // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n\n\n  if (isContentEditable(node)) {\n    return 0;\n  } // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0.\n\n\n  if ((node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {\n    return 0;\n  }\n\n  return node.tabIndex;\n};\n\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\n\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\n\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\n\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n\n  var radioScope = node.form || node.ownerDocument;\n\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n\n  var radioSet;\n\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nvar isHidden = function isHidden(node, displayCheck) {\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  if (!displayCheck || displayCheck === 'full') {\n    while (node) {\n      if (getComputedStyle(node).display === 'none') {\n        return true;\n      }\n\n      node = node.parentElement;\n    }\n  } else if (displayCheck === 'non-zero-area') {\n    var _node$getBoundingClie = node.getBoundingClientRect(),\n        width = _node$getBoundingClie.width,\n        height = _node$getBoundingClie.height;\n\n    return width === 0 && height === 0;\n  }\n\n  return false;\n}; // form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\n\n\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (isInput(node) || node.tagName === 'SELECT' || node.tagName === 'TEXTAREA' || node.tagName === 'BUTTON') {\n    var parentNode = node.parentElement;\n\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> as an immediate child of the disabled\n        //  <fieldset>: if the node is in that legend, it'll be enabled even\n        //  though the fieldset is disabled; otherwise, the node is in a\n        //  secondary/subsequent legend, or somewhere else within the fieldset\n        //  (however deep nested) and it'll be disabled\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n\n          if (child.tagName === 'LEGEND') {\n            if (child.contains(node)) {\n              return false;\n            } // the node isn't in the first legend (in doc order), so no matter\n            //  where it is now, it'll be disabled\n\n\n            return true;\n          }\n        } // the node isn't in a legend, so no matter where it is now, it'll be disabled\n\n\n        return true;\n      }\n\n      parentNode = parentNode.parentElement;\n    }\n  } // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n\n\n  return false;\n};\n\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options.displayCheck) || // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (!isNodeMatchingSelectorFocusable(options, node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {\n    return false;\n  }\n\n  return true;\n};\n\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  candidates.forEach(function (candidate, i) {\n    var candidateTabindex = getTabindex(candidate);\n\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate\n      });\n    }\n  });\n  var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {\n    return a.node;\n  }).concat(regularTabbables);\n  return tabbableNodes;\n};\n\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\n\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\n/*!\n* focus-trap 6.6.1\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar activeFocusTraps = function () {\n  var trapQueue = [];\n  return {\n    activateTrap: function activateTrap(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n    deactivateTrap: function deactivateTrap(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n}();\n\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\n\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\nvar isTabEvent = function isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n}; // Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\n\n\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n  return idx;\n};\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\n\n\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\n\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  var doc = document;\n\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true\n  }, userOptions);\n\n  var state = {\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying the first and last tabbable nodes in all containers/groups in\n    //  the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{ container: HTMLElement, firstTabbableNode: HTMLElement|null, lastTabbableNode: HTMLElement|null }>}\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  var containersContain = function containersContain(element) {\n    return state.containers.some(function (container) {\n      return container.contains(element);\n    });\n  };\n\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n\n    if (!optionValue) {\n      return null;\n    }\n\n    var node = optionValue;\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue);\n\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` refers to no known node\"));\n      }\n    }\n\n    if (typeof optionValue === 'function') {\n      node = optionValue();\n\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` did not return a node\"));\n      }\n    }\n\n    return node;\n  };\n\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node; // false indicates we want no initialFocus at all\n\n    if (getOption({}, 'initialFocus') === false) {\n      return false;\n    }\n\n    if (getNodeForOption('initialFocus') !== null) {\n      node = getNodeForOption('initialFocus');\n    } else if (containersContain(doc.activeElement)) {\n      node = doc.activeElement;\n    } else {\n      var firstTabbableGroup = state.tabbableGroups[0];\n      var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n      node = firstTabbableNode || getNodeForOption('fallbackFocus');\n    }\n\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n\n    return node;\n  };\n\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.tabbableGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container);\n\n      if (tabbableNodes.length > 0) {\n        return {\n          container: container,\n          firstTabbableNode: tabbableNodes[0],\n          lastTabbableNode: tabbableNodes[tabbableNodes.length - 1]\n        };\n      }\n\n      return undefined;\n    }).filter(function (group) {\n      return !!group;\n    }); // remove groups with no tabbable nodes\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus')) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n  };\n\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n\n    if (node === doc.activeElement) {\n      return;\n    }\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus');\n    return node ? node : previousActiveElement;\n  }; // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n\n\n  var checkPointerDown = function checkPointerDown(e) {\n    if (containersContain(e.target)) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(e.target)\n      });\n      return;\n    } // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    } // otherwise, prevent the click\n\n\n    e.preventDefault();\n  }; // In case focus escapes the trap for some strange reason, pull it back in.\n\n\n  var checkFocusIn = function checkFocusIn(e) {\n    var targetContained = containersContain(e.target); // In Firefox when you Tab out of an iframe the Document is briefly focused.\n\n    if (targetContained || e.target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = e.target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  }; // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n\n\n  var checkTab = function checkTab(e) {\n    updateTabbableNodes();\n    var destinationNode = null;\n\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's tabbable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findIndex(state.tabbableGroups, function (_ref) {\n        var container = _ref.container;\n        return container.contains(e.target);\n      });\n\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back in to...\n        if (e.shiftKey) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (e.shiftKey) {\n        // REVERSE\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {\n          var firstTabbableNode = _ref2.firstTabbableNode;\n          return e.target === firstTabbableNode;\n        });\n\n        if (startOfGroupIndex < 0 && state.tabbableGroups[containerIndex].container === e.target) {\n          // an exception case where the target is the container itself, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        }\n      } else {\n        // FORWARD\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var lastTabbableNode = _ref3.lastTabbableNode;\n          return e.target === lastTabbableNode;\n        });\n\n        if (lastOfGroupIndex < 0 && state.tabbableGroups[containerIndex].container === e.target) {\n          // an exception case where the target is the container itself, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = _destinationGroup.firstTabbableNode;\n        }\n      }\n    } else {\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n\n    if (destinationNode) {\n      e.preventDefault();\n      tryFocus(destinationNode);\n    } // else, let the browser take care of [shift+]tab and move the focus\n\n  };\n\n  var checkKey = function checkKey(e) {\n    if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates) !== false) {\n      e.preventDefault();\n      trap.deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  };\n\n  var checkClick = function checkClick(e) {\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n\n    if (containersContain(e.target)) {\n      return;\n    }\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }; //\n  // EVENT LISTENERS\n  //\n\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    } // There can be only one listening focus trap at a time\n\n\n    activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  }; //\n  // TRAP DEFINITION\n  //\n\n\n  trap = {\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n\n      if (onActivate) {\n        onActivate();\n      }\n\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n\n        addListeners();\n\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      activeFocusTraps.deactivateTrap(trap);\n      var onDeactivate = getOption(deactivateOptions, 'onDeactivate');\n      var onPostDeactivate = getOption(deactivateOptions, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(deactivateOptions, 'checkCanReturnFocus');\n\n      if (onDeactivate) {\n        onDeactivate();\n      }\n\n      var returnFocus = getOption(deactivateOptions, 'returnFocus', 'returnFocusOnDeactivate');\n\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = true;\n      removeListeners();\n      return this;\n    },\n    unpause: function unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n\n      if (state.active) {\n        updateTabbableNodes();\n      }\n\n      return this;\n    }\n  }; // initialize container elements\n\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap as c };\n","function generateUniqueId() {\n  // Math.random should be unique because of its seeding algorithm.\n  // Convert it to base 36 (numbers + letters), and grab the first 9 characters\n  // after the decimal.\n  return '_' + Math.random().toString(36).substr(2, 9);\n}\n/**\n * Checks if the given element has at least one child node at the given slot\n * @param el The element which has a named slot inside\n * @param slotName The name of the slot to check\n * @return `true` if a child at the slot exists, otherwise `false`\n */\nfunction hasSlotContent(el, slotName) {\n  return el.querySelectorAll(`[slot=\"${slotName}\"]`).length > 0;\n}\n/**\n * Returns the content of a given slot\n * @param el The element which has a named slot inside\n * @param slotName The name of the slot to check\n * @return {NodeList} the content of the slot\n */\nfunction getSlotContent(el, slotName) {\n  return el.querySelectorAll(`[slot=\"${slotName}\"]`);\n}\n/**\n * Elements inside of web components sometimes need to inherit global attributes\n * set on the host. For example, the inner input in `didomi-input` should inherit\n * the `title` attribute that developers set directly on `didomi-input`. This\n * helper function should be called in componentWillLoad and assigned to a variable\n * that is later used in the render function.\n *\n * This does not need to be reactive as changing attributes on the host element\n * does not trigger a re-render.\n * @param el The element\n * @param attributes A list of attributes to inherit\n */\nconst inheritAttributes = (el, attributes = []) => {\n  const attributeObject = {};\n  attributes.forEach(attr => {\n    if (el.hasAttribute(attr)) {\n      const value = el.getAttribute(attr);\n      /* istanbul ignore else */\n      if (value !== null) {\n        attributeObject[attr] = el.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n  return attributeObject;\n};\n/**\n *\n * @param name tag name of the original component we want to create\n * @param hostName tag name of the host component\n * @returns tag name with prefix, if any\n */\nfunction createComponentWithPrefix(name, hostName) {\n  const splittedHostName = hostName.toLowerCase().split('-');\n  if (splittedHostName[0] !== 'didomi') {\n    let didomiReached = false;\n    const prefix = splittedHostName.reduce((prev, cur) => {\n      if (cur === 'didomi' || didomiReached) {\n        didomiReached = true;\n        return prev;\n      }\n      else {\n        return `${prev}${cur}-`;\n      }\n    }, '');\n    return `${prefix}${name}`;\n  }\n  else {\n    return name;\n  }\n}\n/**\n * Debounce execution of function for specified delay\n * @param func function to implement debounce to\n * @param delay number of milliseconds to debounce func execution\n * @returns passed function decorated with debounced execution\n */\nfunction debounce(func, delay = 300) {\n  let timerId;\n  return (...args) => {\n    // Cancels the setTimeout method execution\n    clearTimeout(timerId);\n    // Executes the func after delay time.\n    timerId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n/**\n * Returns the default overlay container, otherwise it creates it and returns it\n * @return {HTMLElement} the overlay container\n */\nfunction getOverlayElement() {\n  const overlayWrapper = document.body.querySelector('.didomi-overlay-container');\n  if (overlayWrapper) {\n    return overlayWrapper;\n  }\n  else {\n    const overlayWrapperContainer = document.createElement('div');\n    overlayWrapperContainer.classList.add('didomi-overlay-container');\n    document.body.appendChild(overlayWrapperContainer);\n    return overlayWrapperContainer;\n  }\n}\n/**\n * Moves an element to the overlay section\n * Cannot clone the element because https://github.com/ionic-team/stencil/issues/2197\n * So we move the modal from the element to the overlay and we bring it back on close\n * @param {HTMLElement} el The element to overlay\n * @param {string} portalId The name of the overlay name. If no name is provided defaults to body.\n * @return {HTMLElement} the element in the overlay\n */\nfunction createOverlayPortal(el, portalId) {\n  const overlayWrapper = document.getElementById(portalId);\n  el.style.zIndex = '1';\n  if (overlayWrapper) {\n    if (!overlayWrapper.className.includes('didomi-overlay-container')) {\n      overlayWrapper.classList.add('didomi-overlay-container');\n    }\n    overlayWrapper.appendChild(el);\n  }\n  else {\n    const exitingOverlayWrapper = document.querySelector('.didomi-overlay-container');\n    if (exitingOverlayWrapper) {\n      exitingOverlayWrapper.appendChild(el);\n    }\n    else {\n      const overlayWrapperContainer = document.createElement('div');\n      overlayWrapperContainer.classList.add('didomi-overlay-container');\n      overlayWrapperContainer.style.zIndex = '1000';\n      overlayWrapperContainer.style.position = 'fixed';\n      overlayWrapperContainer.appendChild(el);\n      document.body.appendChild(overlayWrapperContainer);\n    }\n  }\n}\n/**\n * Removes the element from the portal overlay and moves it back to the original parent.\n * @param {string} elementId The id of the element to remove\n * @param {HTMLElement} originalParent The original parent before the element was moved to the overlay.\n * @return {HTMLElement} the element in the overlay\n */\nfunction destroyOverlayPortal(elementId, originalParent) {\n  const element = document.body.querySelector(`.didomi-overlay-container #${elementId}`);\n  if (!element || !originalParent)\n    return;\n  originalParent === null || originalParent === void 0 ? void 0 : originalParent.appendChild(element);\n}\n/**\n * Copies down all data attributes to a children component using a suffix at the end.\n * Use it as <didomi-bottom-bar data-cy=\"bottom-bar\"> would could create its button inside\n * with a data-cy=\"buttom-bar-button\".\n * @param {string} hostElement The host element\n * @param {HTMLElement} element The element where to include the data attributes suffixed.\n * @param {string} suffixName The suffix to append at the end of each data-attribute\n */\nconst addDataSuffix = (hostElement, element, suffixName) => {\n  if (!hostElement || !element)\n    return;\n  const dataAttributes = Array.from(hostElement.attributes)\n    .filter(a => a.name.startsWith('data-'))\n    .map(a => ({ name: a.name, value: `${a.value}-${suffixName}` }));\n  if (!(dataAttributes === null || dataAttributes === void 0 ? void 0 : dataAttributes.length))\n    return;\n  for (const dataAttribute of dataAttributes) {\n    element.setAttribute(dataAttribute.name, dataAttribute.value);\n  }\n};\n/**\n * Patched version of requestAnimationFrame that avoids ngzone\n * Use only when you know ngzone should not run\n * Use when you have to set a variable in the componentDidLoad event which will otherwise trigger a re-render\n * eg: https://github.com/ionic-team/ionic-framework/blob/master/core/src/components/item/item.tsx#L176\n */\n/* istanbul ignore next */\nconst raf = (h) => {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n  return setTimeout(h);\n};\n\nexport { addDataSuffix as a, createOverlayPortal as b, createComponentWithPrefix as c, destroyOverlayPortal as d, debounce as e, getSlotContent as f, generateUniqueId as g, hasSlotContent as h, inheritAttributes as i, getOverlayElement as j, raf as r };\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}"],"names":["candidateSelectors","candidateSelector","join","matches","Element","prototype","msMatchesSelector","webkitMatchesSelector","getTabindex","node","tabindexAttr","parseInt","getAttribute","isNaN","contentEditable","isContentEditable","nodeName","tabIndex","sortOrderedTabbables","a","b","documentOrder","isInput","tagName","isNonTabbableRadio","type","isRadio","name","radioSet","radioScope","form","ownerDocument","queryRadios","querySelectorAll","window","CSS","escape","err","console","error","message","checked","nodes","i","length","getCheckedRadio","isTabbableRadio","isNodeMatchingSelectorFocusable","options","disabled","isHiddenInput","displayCheck","getComputedStyle","visibility","nodeUnderDetails","call","parentElement","_node$getBoundingClie","getBoundingClientRect","width","height","display","isHidden","Array","slice","apply","children","some","child","isDetailsWithSummary","parentNode","item","contains","isDisabledFromFieldset","isNodeMatchingSelectorTabbable","tabbable","el","regularTabbables","orderedTabbables","candidates","includeContainer","filter","unshift","getCandidates","bind","forEach","candidate","candidateTabindex","push","sort","map","concat","focusableCandidateSelector","isFocusable","Error","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","sym","getOwnPropertyDescriptor","enumerable","_defineProperty","obj","key","value","defineProperty","configurable","writable","activeFocusTraps","trapQueue","activateTrap","trap","activeTrap","pause","trapIndex","indexOf","splice","deactivateTrap","unpause","delay","fn","setTimeout","findIndex","arr","idx","every","valueOrHandler","_len","arguments","params","_key","createFocusTrap","elements","userOptions","doc","document","config","target","source","getOwnPropertyDescriptors","defineProperties","_objectSpread2","returnFocusOnDeactivate","escapeDeactivates","delayInitialFocus","state","containers","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","delayInitialFocusTimer","undefined","getOption","configOverrideOptions","optionName","configOptionName","containersContain","element","container","getNodeForOption","optionValue","querySelector","getInitialFocusNode","activeElement","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","tabbableNodes","lastTabbableNode","group","tryFocus","focus","preventScroll","toLowerCase","select","isSelectableInput","getReturnFocusNode","previousActiveElement","checkPointerDown","e","clickOutsideDeactivates","deactivate","returnFocus","allowOutsideClick","preventDefault","checkFocusIn","targetContained","Document","stopImmediatePropagation","checkKey","keyCode","isEscapeEvent","isTabEvent","destinationNode","containerIndex","_ref","shiftKey","startOfGroupIndex","_ref2","destinationGroupIndex","lastOfGroupIndex","_ref3","_destinationGroupIndex","checkTab","checkClick","addListeners","addEventListener","capture","passive","removeListeners","removeEventListener","activate","activateOptions","this","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","then","deactivateOptions","clearTimeout","onDeactivate","onPostDeactivate","checkCanReturnFocus","finishDeactivation","updateContainerElements","containerElements","elementsAsArray","Boolean","generateUniqueId","Math","random","toString","substr","hasSlotContent","slotName","getSlotContent","inheritAttributes","attributeObject","attr","hasAttribute","removeAttribute","createComponentWithPrefix","hostName","splittedHostName","split","didomiReached","prefix","reduce","prev","cur","debounce","func","timerId","_this","args","getOverlayElement","overlayWrapper","body","overlayWrapperContainer","createElement","classList","add","appendChild","createOverlayPortal","portalId","getElementById","style","zIndex","className","includes","exitingOverlayWrapper","position","destroyOverlayPortal","elementId","originalParent","addDataSuffix","hostElement","suffixName","dataAttributes","from","attributes","startsWith","_step","_iterator","_createForOfIteratorHelper","s","n","done","dataAttribute","setAttribute","f","raf","h","__zone_symbol__requestAnimationFrame","requestAnimationFrame","o","allowArrayLike","it","Symbol","iterator","isArray","F","_e","TypeError","normalCompletion","didErr","step","next","_e2"],"sourceRoot":""}