{"version":3,"file":"static/js/5688.363fa00d.chunk.js","mappings":"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","sources":["../node_modules/@didomi/ui-atoms/dist/esm/offset-21f9211d.js","../node_modules/@didomi/ui-atoms/dist/esm/preventOverflow-cbf2cbc5.js"],"sourcesContent":["import { i as isShadowRoot, g as getWindow, a as getDocumentElement, b as getWindowScrollBarX, c as getWindowScroll, d as getComputedStyle, m as max, v as viewport, e as isHTMLElement, f as min, h as getBoundingClientRect, l as listScrollParents, j as getParentNode, k as getOffsetParent, n as isElement, o as getNodeName, p as basePlacements, q as computeOffsets, r as popper, s as clippingParents, t as right, u as bottom, w as top, x as reference, y as getVariation, z as variationPlacements, A as getBasePlacement, B as placements, C as auto, D as start, E as left } from './popperOverlay-5341d24d.js';\n\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}\n\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}\n\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n\nvar hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash$1[matched];\n  });\n}\n\nvar hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash[matched];\n  });\n}\n\nfunction getViewportRect(element) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\n  // can be obscured underneath it.\n  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n  // if it isn't open, so if this isn't available, the popper will be detected\n  // to overflow the bottom of the screen too early.\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n    // errors due to floating point numbers, so we need to check precision.\n    // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n    // Feature detection fails in mobile emulation mode in Chrome.\n    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n    // 0.001\n    // Fallback here: \"Not Safari\" userAgent\n\n    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + getWindowScrollBarX(element),\n    y: y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -winScroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n\nfunction getInnerBoundingClientRect(element) {\n  var rect = getBoundingClientRect(element);\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var referenceElement = state.elements.reference;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = getBoundingClientRect(referenceElement);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n\n/*:: type OverflowsMap = { [ComputedPlacement]: number }; */\n\n/*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements$1.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements$1;\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\nconst flip$1 = {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nconst offset$1 = {\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n};\n\nexport { detectOverflow as d, flip$1 as f, getFreshSideObject as g, offset$1 as o };\n","import { m as max, f as min, A as getBasePlacement, y as getVariation, k as getOffsetParent, F as getMainAxisFromPlacement, w as top, E as left, u as bottom, t as right, D as start, G as getLayoutRect } from './popperOverlay-5341d24d.js';\nimport { d as detectOverflow, g as getFreshSideObject } from './offset-21f9211d.js';\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis || checkAltAxis) {\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min$1 = popperOffsets[mainAxis] + overflow[mainSide];\n    var max$1 = popperOffsets[mainAxis] - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n\n    if (checkMainAxis) {\n      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n      popperOffsets[mainAxis] = preventedOffset;\n      data[mainAxis] = preventedOffset - offset;\n    }\n\n    if (checkAltAxis) {\n      var _mainSide = mainAxis === 'x' ? top : left;\n\n      var _altSide = mainAxis === 'x' ? bottom : right;\n\n      var _offset = popperOffsets[altAxis];\n\n      var _min = _offset + overflow[_mainSide];\n\n      var _max = _offset - overflow[_altSide];\n\n      var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);\n\n      popperOffsets[altAxis] = _preventedOffset;\n      data[altAxis] = _preventedOffset - _offset;\n    }\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nconst preventOverflow$1 = {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};\n\nexport { preventOverflow$1 as p };\n"],"names":["getFreshSideObject","top","right","bottom","left","hash$1","getOppositePlacement","placement","replace","matched","hash","start","end","getOppositeVariationPlacement","rectToClientRect","rect","Object","assign","x","y","width","height","getClientRectFromMixedType","element","clippingParent","viewport","win","getWindow","html","getDocumentElement","visualViewport","clientWidth","clientHeight","test","navigator","userAgent","offsetLeft","offsetTop","getWindowScrollBarX","getViewportRect","isHTMLElement","getBoundingClientRect","clientTop","clientLeft","getInnerBoundingClientRect","_element$ownerDocumen","winScroll","getWindowScroll","body","ownerDocument","max","scrollWidth","scrollHeight","scrollLeft","scrollTop","getComputedStyle","direction","getDocumentRect","getClippingParents","clippingParents","listScrollParents","getParentNode","clipperElement","indexOf","position","getOffsetParent","isElement","filter","parent","child","rootNode","getRootNode","contains","isShadowRoot","next","isSameNode","parentNode","host","getNodeName","detectOverflow","state","options","value","_options","_options$placement","_options$boundary","boundary","_options$rootBoundary","rootBoundary","_options$elementConte","elementContext","popper","_options$altBoundary","altBoundary","_options$padding","padding","paddingObject","mergePaddingObject","basePlacements","reduce","hashMap","key","altContext","reference","referenceElement","elements","popperRect","rects","clippingClientRect","mainClippingParents","concat","firstClippingParent","clippingRect","accRect","min","getClippingRect","contextElement","referenceClientRect","popperOffsets","computeOffsets","strategy","popperClientRect","elementClientRect","overflowOffsets","offsetData","modifiersData","offset","keys","forEach","multiply","axis","flip$1","name","enabled","phase","fn","_ref","_skip","_options$mainAxis","mainAxis","checkMainAxis","_options$altAxis","altAxis","checkAltAxis","specifiedFallbackPlacements","fallbackPlacements","_options$flipVariatio","flipVariations","allowedAutoPlacements","preferredPlacement","basePlacement","getBasePlacement","auto","oppositePlacement","getExpandedFallbackPlacements","placements","acc","_options$allowedAutoP","variation","getVariation","placements$1","variationPlacements","allowedPlacements","length","overflows","sort","a","b","computeAutoPlacement","referenceRect","checksMap","Map","makeFallbackChecks","firstFittingPlacement","i","_basePlacement","isStartVariation","isVertical","len","overflow","mainVariationSide","altVariationSide","checks","push","every","check","set","_loop","_i","fittingPlacement","find","get","slice","reset","requiresIfExists","data","offset$1","requires","_ref2","_options$offset","invertDistance","skidding","distance","distanceAndSkiddingToXY","_data$state$placement","within","min$1","max$1","preventOverflow$1","_options$tether","tether","_options$tetherOffset","tetherOffset","isBasePlacement","getMainAxisFromPlacement","tetherOffsetValue","mainSide","altSide","additive","minLen","maxLen","arrowElement","arrow","arrowRect","getLayoutRect","arrowPaddingObject","arrowPaddingMin","arrowPaddingMax","arrowLen","minOffset","maxOffset","arrowOffsetParent","clientOffset","offsetModifierValue","tetherMin","tetherMax","preventedOffset","_mainSide","_altSide","_offset","_min","_max","_preventedOffset"],"sourceRoot":""}